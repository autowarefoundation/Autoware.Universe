// Copyright 2024 TIER IV, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <autoware/behavior_path_planner_common/planner_data_yaml.hpp>
#include <autoware_test_utils/mock_data_parser.hpp>

namespace autoware::behavior_path_planner
{

std::pair<YAML::Node, std::string> get_planner_data_yaml(
  const nav_msgs::msg::Odometry & self_odometry,
  const geometry_msgs::msg::AccelWithCovarianceStamped & self_acceleration,
  const autoware_perception_msgs::msg::PredictedObjects & dynamic_object,
  [[maybe_unused]] const nav_msgs::msg::OccupancyGrid & occupancy_grid,
  [[maybe_unused]] const nav_msgs::msg::OccupancyGrid & costmap,
  tier4_planning_msgs::msg::LateralOffset::ConstSharedPtr lateral_offset,
  const autoware_adapi_v1_msgs::msg::OperationModeState & operation_mode,
  const autoware_planning_msgs::msg::LaneletRoute & route_ptr,
  autoware_perception_msgs::msg::TrafficLightGroupArray::ConstSharedPtr traffic_signal)
{
  YAML::Node planner_data;

  planner_data["format_version"] =
    static_cast<std::underlying_type_t<YamlDataFormatVersion>>(k_current_planner_data_yaml_format);

  planner_data["self_odometry"]["type"] =
    autoware::behavior_path_planner::get_typename<decltype(self_odometry)>();
  planner_data["self_odometry"]["body"] = YAML::Load(nav_msgs::msg::to_yaml(self_odometry));

  planner_data["self_acceleration"]["type"] =
    autoware::behavior_path_planner::get_typename<decltype(self_acceleration)>();
  planner_data["self_acceleration"]["body"] =
    YAML::Load(geometry_msgs::msg::to_yaml(self_acceleration));

  planner_data["dynamic_object"]["type"] =
    autoware::behavior_path_planner::get_typename<decltype(dynamic_object)>();
  planner_data["dynamic_object"]["body"] =
    YAML::Load(autoware_perception_msgs::msg::to_yaml(dynamic_object));

  if (lateral_offset) {
    planner_data["lateral_offset"]["type"] =
      autoware::behavior_path_planner::get_typename<decltype(*lateral_offset)>();
    planner_data["lateral_offset"]["body"] =
      YAML::Load(tier4_planning_msgs::msg::to_yaml(*lateral_offset));
  }

  planner_data["operation_mode"]["type"] =
    autoware::behavior_path_planner::get_typename<decltype(operation_mode)>();
  planner_data["operation_mode"]["body"] =
    YAML::Load(autoware_adapi_v1_msgs::msg::to_yaml(operation_mode));

  planner_data["route"]["type"] =
    autoware::behavior_path_planner::get_typename<decltype(route_ptr)>();
  planner_data["route"]["body"] = YAML::Load(autoware_planning_msgs::msg::to_yaml(route_ptr));

  if (traffic_signal) {
    planner_data["traffic_signal"]["type"] =
      autoware::behavior_path_planner::get_typename<decltype(*traffic_signal)>();
    planner_data["traffic_signal"]["body"] =
      YAML::Load(autoware_perception_msgs::msg::to_yaml(*traffic_signal));
  }

  const std::string desc = std::string(R"(#
# AUTO GENERATED by autoware_behavior_path_planner::planner_data_saver
# format1:
# <field-name>:
#   type: <typename>
#   body:
#     <`to-yaml` style of message> or <yaml-cpp repr of the object>
# fields:
# - self_odometry
# - self_acceleration
# - dynamic_object
# - lateral_offset(optional)
# - operation_mode
# - route
# - traffic_signal(optional)

)");

  return {planner_data, desc};
}

bool update_planner_data_v1(PlannerData & planner_data, const YAML::Node & planner_data_yaml)
{
  const auto self_odometry =
    autoware::test_utils::parse<nav_msgs::msg::Odometry>(planner_data_yaml["self_odometry"]);
}

bool update_planner_data(PlannerData & planner_data, const YAML::Node & planner_data_yaml)
{
  if (!planner_data_yaml["format"]) {
    return false;
  }
  const auto format_version = planner_data_yaml["format"].as<int>();
  if (format_version == 1) {
    return update_planner_data_v1(planner_data, planner_data_yaml);
  }
  return false;
}

}  // namespace autoware::behavior_path_planner
